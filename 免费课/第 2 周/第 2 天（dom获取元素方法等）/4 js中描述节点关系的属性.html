<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<div id="div1">
    <ul id="ul1">
        <!--<li></li>-->
        <!--li-->
        <li id="li2"></li>
        <li></li>
        <li></li>
    </ul>
</div>
<div id="div2"></div>
<script>
    // node：节点的意思, 所有的元素，换行，注释，文本等都可以叫做节点
    // parentNode: 父节点
    // childNodes: 所有的子节点（有可能有注释，换行，文本，元素只是其中的一部分）
    var li2 = document.getElementById('li2');
    var ul1 = document.getElementById('ul1');

    console.log(li2.parentNode); //父节点
    console.log(ul1.childNodes); // 所有的子节点
    console.log(ul1.children); // 所有的元素(是元素)子节点, 不兼容

    function children(ele) {
        var childNodes = ele.childNodes;
        var ary = [];
        for (var i = 0; i < childNodes.length; i++) {
            var curNode = childNodes[i];
            if (curNode.nodeType === 1) {
                ary.push(curNode);
            }
        }
        return ary;
    }

    console.log(children(ul1));

    /*
     *                      元素       文本         注释       document
     *
     * nodeType(节点类型)     1          3           8             9
     *
     * nodeName(节点名称)   大写标签名   #text      #comment     #document
     *
     * nodeValue(节点值)     null      文本内容     注释内容       null
     *
     * */

    // previousSibling  上一个哥哥节点(是节点)
    // previousElementSibling 上一个元素(是元素)哥哥节点  不兼容

    // nextSibling  下一个弟弟节点 (是节点)
    // nextElementSibling 下一个元素弟弟节点(是元素) 不兼容

    // firstChild 第一个子节点(是节点)
    // firstElementChild 第一个元素子节点(是元素) 不兼容

    // lastChild 最后一个子节点(节点)
    // lastElementChild 最后一个元素子节点(是元素) 不兼容

    //PS: 如果一个元素不存在previousSibling / previousElementSibling 那么返回值是null，null可以作为一个false条件

    console.log(li2.previousElementSibling);

    function prevEleSibling(ele) {
        var prev = ele.previousSibling;
        while (prev && prev.nodeType !== 1) {
            prev = prev.previousSibling;
        }
        return prev;
    }
</script>
</body>
</html>